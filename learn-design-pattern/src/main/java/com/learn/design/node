
                                                创建型模式

** 单例模式 singleton **
    一、什么是单例模式
    1、所谓类的单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，
    2、并且该类只提供一个取得其对象实例的方法(静态方法)。
    比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。
    SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。

    二、单例模式总工有8种写法：
    1、饿汉式 静态常量    (在不确定一定用到的时候会浪费内存,线程安全)    final static Singleton INSTANCE = new Singleton();
    2、饿汉式 静态代码块  (在不确定一定用到的时候会浪费内存,线程安全)    static {INSTANCE = new Singleton();}
    3、懒汉式 使用再创建  (线程不安全)              getInstance();
    4、懒汉式 同步方法    (线程安全了，效率低)       synchronized getInstance();
    5、懒汉式 同步代码块  (反而线程不安全了)         synchronized(){}
    6、懒汉式 双重检索    (线程安全)                volatile + 双if + 静态代码块
    7、静态内部类        1、利用JVM类加载器加载外部类时不加载静态内部类   2、利用JVM装载类去保证线程安全
    8、枚举             利用jdk1.5之后枚举类的特性

    三、推荐使用的有：
    在确保类一定会使用的时候，饿汉式两种可以使用。(1、2)
    双重检索、静态内部类、枚举 可以使用。(6、7、8)

    四、单例模式的经典使用：
    JDK中的 java.lang.Runtime就是单例模式。
    使用的是饿汉式写法。
    如下：
    private static Runtime currentRuntime = new Runtime();
    public static Runtime getRuntime() { return currentRuntime; }
    private Runtime() {}

    五、使用注意细节：
    1、单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
    2、当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new
    3、单例模式的使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多
    (即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如：数据源、session  工厂等)



** 工厂模式（简单工厂、工厂方法、抽象工厂） factory **
    一、简单工厂模式
    简单工厂模式是属于创建型模式，是工厂模式的一种。
    简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
    简单工厂模式是 工厂模式家族 中最简单实用的模式。
    简单工厂模式：定义了一个创建对象的类，由这个类来 封装实例化对象的行为(代码)。
    在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

    二、工厂方法
    工厂方法模式： 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

    三、抽象工厂
    抽象工厂模式：定义了一个 interface  用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
    抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
    从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
    将工厂抽象成 两层，AbsFactory( 抽象工厂) 和  具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。
    这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

    四、JDK中对工厂模式的运用
    Calendar类  使用的是简单工厂模式
    getInstance() ->  createCalendar(TimeZone zone,Locale aLocale) switch判断 Local对象 去创建不用的日历对象返回
    class JapaneseImperialCalendar extends Calendar{...}
    class BuddhistCalendar extends GregorianCalendar{...}
    ...

    五、工厂模式小节
    工厂模式的意义
        将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
    三种工厂模式
        简单工厂模式、工厂方法模式、抽象工厂模式。
    设计模式的依赖抽象原则
        创建对象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。
        有的书上说，变量不要直接持有具体类的引用。
        不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)。
        不要覆盖基类中已经实现的方法。



** 原型模式 prototype **
    一、什么是原型模式
    Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，
    但是需要实现 clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式。

    原型模式(Prototype 模式)是指：用 原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
    原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。
    工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即  对象.clone()。
    形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。

    二、Spring Bean的创建过程中使用到了原型模式
    AbstractBeanFactory 类  doGetBean() 方法里判断配置文件的配置类型
      if (mbd.isSingleton()) ...
      else if (mbd.isPrototype())

    三、浅拷贝和深拷贝
    浅拷贝
    对于数据类型是 基本数据类型 的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
    对于数据类型是 引用数据类型 的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，
       也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。
    因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
    实现Cloneable接口的克隆办法就是浅拷贝。

    深拷贝
    复制对象的所有基本数据类型的成员变量值。
    所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。
       也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型) 进行拷贝。
    深拷贝实现方式 1：重写 clone 方法来实现深拷贝。
    深拷贝实现方式 2：通过 对象序列化实现深拷贝(推荐)。

    四、原型模式使用注意事项
    创建新的对象比较复杂时，可以利用原型模式简化 对象的创建过程，同时也能够提高效率。
    不用重新初始化对象，而是 动态地获得对象运行时的状态。
    如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。
    在实现深克隆的时候可能需要比较复杂的代码。
    缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。


** 建造者模式 builder **
    一、什么是建造者模式
    建造者模式的核心思想就是把产品和产品建造者解耦。
    基本介绍：
    建造者模式又叫 生成器模式，是一种对象 构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
    建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

    二、角色
    1) Product（产品角色）： 一个具体的产品对象。
    2) Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 接口/抽象类。
    3) ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。
    4) Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。
        它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

    三、建造者模式在JDK中的使用
    StringBuilder:
    final class StringBuilder extends AbstractStringBuilder
    class AbstractStringBuilder implements Appendable, CharSequence
    在 interface Appendable 中定义了高度抽象的append()方法

    分析角色：
    Appendable 是抽象建造者
    AbstractStringBuilder 是建造者，不能实例化
    StringBuilder 其实即时指挥者，也是具体的建造者，建造方法的实现是它父类完成的

    四、建造者模式使用注意事项
    1、客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
    2、每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。
    3、可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
    4、增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
    5、建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
    6、如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
    7、抽象工厂模式 VS 建造者模式
        抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，
        只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。




                                            结构型模式

** 适配器模式 Adapter **
    一、
    适配器模式：将某个类的接口转换成客户端期望的另一个接口表示， 主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。
    其别名为包装器(Wrapper)，适配器模式属于结构型模式。
    主要分为三类： 类适配器模式、对象适配器模式、接口适配器模式。

    类适配器和对象适配器是通一种思路的两种不同实现。
    接口适配器，一些书籍称为：适配器模式(DefaultAdapter Pattern)或 缺省适配器模式。
    核心思路：当 不需要全部实现接口提供的方法时，可先 设计一个抽象类实现 接口，并为该接口中每个方法提供一个 默认实现（空方法），
    那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。
    适用于一个接口不想使用其所有的方法的情况。

    二、SpringMVC中的接口适配器
    SpringMvc 中的 HandlerAdapter, 就使用了适配器模式，SpringMVC 处理请求的流程回顾
    使用 HandlerAdapter 的原因分析:
    可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，
    需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则。

    DispatcherServlet -> doDispatch()
    HandlerAdapter适配不同的Handler


    三、适配器模式的注意事项和细节
    三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。
    类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承
    对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有
    接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现
    Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。
    实际开发中，实现起来不拘泥于我们讲解的三种经典形式。






















































