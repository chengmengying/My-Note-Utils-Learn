字字珠玑，很适合精读。
# 《深入理解Java虚拟机》周志明
## 展望未来  
即时编译器：应用系统预热之后，热点代码被HotSpot的探测机制定位捕获，将其编译为物理硬件可以直接指向的机器码。所以即时编译器输入代码的质量也决定了代码运行的效率。  
C1:耗时短，输出代码优化程度低的客户端编译器  
C2:耗时长，但是输出代码优化质量更高的服务端编译器 Graal编译器作为C2的替代产品。  
本地类型变量推断  

## 一、Java内存区域与内存溢出异常 
Java与C++之间隔着内存动态分配和垃圾收集器。  
  
### 运行时数据区  
1、程序计数器：当前线程所执行的字节码的行号指示器。下一条指令的地址。字节码解释器改变这个计数器的值来选取下一条需要执行的字节码指令。
它是程序控制流的指示器，分支、循环、异常等等都需要依赖于这个计数器。  
Java的多线程是通过线程轮流切换、分配CPU执行时间来实现的。在一个确定的时间，cpu只可能执行其中的一条指令，为了切换线程之后能找到准确的位置，程序计数器是线程私有的。    
若某个线程正在执行的是一个Java方法，那么这个线程的程序计数器是字节码指令的地址。如果正在执行的是本地方法Native，这个计数器的值是空Undefined。
这个区域不会有OutOfMemoryError。
  
2、Java虚拟机栈：描述的是Java方法执行线程内存模型。每个方法被执行的时候都会创建一个栈帧 Stack Frame,里面存储的是局部变量表、操作数栈、动态链接、方法出口等信息。  
存储局部变量的空间是以Solt槽来表示，除了double和long类型是占据两个槽之外，其余的数据类型只占用一个。  
如果线程请求栈的深度大于虚拟机允许的深度，将抛出StackOverlowError异常，如果是运行虚拟机栈容量是可以扩容的，当请求不到足够的内存时，会抛出OutOfMemoryError异常。  
  
3、本地方法栈：与虚拟机栈发挥的作用相似。虚拟机栈为Java方法服务（字节码），本地方法栈为本地方法提供服务（Native）。

4、堆：虚拟机管理的内存中最大的一块，被所有线程共享，唯一目的就是存放对象实例。几乎所有的对象实例都会在这里被分配。  
几乎（即时编译技术的进步，逃逸分析，栈上分配，标量替换，这些技术使得在堆中分配对象是不绝对的）  
现代的大部分垃圾收集理论都是基于分代收集的概念设计的，所以有新生代，老年代，永久代，Eden区，幸存者from区，幸存者to区域。  
线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB）,用于提升对象分配的效率。
堆空间在物理上不连续，在逻辑上连续。虚拟机参数可以设定堆的大小。-Xmx和-Xms,当堆没有内存能完成实例分配，堆也无法再扩展的时候，就会抛出OutOfMemory异常。

5、方法区：每个线程的共享数据，用于存储已经被虚拟机加载的类型信息、常量、静态常量、即时编译器编译之后的代码缓存等数据。  
运行时常量池也是方法区的一部分。Class文件中除了有版本、字段、方法、接口，还有常量池Conttant Pool Table,存储编译期间生产的各种字面量与符号引用，当类加载了之后，，这些信息就被存放到方法区的运行时常量池中。另外，运行期间也能动态的把新的常量放入池中。
当无法申请到内存的时候会抛出OutOfMemory异常。  

6、直接内存：不是虚拟机运行时数据区的一部分，但是频繁使用，也会导致OOM。
NIO:一种基于通道和缓冲区的IO方式，它可以直接使用Native方法直接分配堆外内存，通过堆内存中的DierctByteBuffer直接操作内存数据，能显著提升IO性能。
当设置内存时，若忽略掉这部分数据，使得内存区域的综合超过了物理内存的限制，在动态扩展的时候就会出现OOM。

### HotSpot虚拟机在新建对象的时候到底发生了什么？   
Java程序在运行过程中无时无刻都在创建对象，当虚拟机遇到一条创建对象的字节码指令的时候：  
1、首先检查指令的参数在常量池中是否能够定位到一个类的符号引用，并且检查这个符号引用的类是否已经被加载、解析、初始化过。（检查要创建的对象的类型是否在常量池中存在。）  
2、加载完毕之后开始为这个对象分配内存，所需要的内存空间大小在类加载之后是能够确定的。  
&emsp;2.1、指针碰撞：假设堆内存是规整的（使用过的内存和空闲的内存时隔开的，中间使用指针作为界线指示器），就只需要把指针往空闲方挪动即可，步长等于对象在加载之后的确定的需要占据空间的大小。  
&emsp;2.2、空闲列表：假设堆内存不是规则的，虚拟机就必须维护一个记录堆空间使用情况列表，从列表中找出一块足够大的空间划分给该对象。  
&emsp;因此，选择哪种分配方式由堆内存是否规整决定，而堆内存是否规整又由使用的垃圾收集器是否具有压缩整理能力决定。  
&emsp;比如：Serial,ParNew是具有压缩整理能力的垃圾收集器，可以使用指针碰撞办法来分配对象内存，而像CMS这种基于清除算法的收集器，理论上只能使用复杂的空闲列表分配算法来分配对象的内存。  
3、空间划分完毕之后，还有考虑线程的安全性问题。创建对象的动作在虚拟机中是非常频繁的。    
&emsp;3.1、采用CAS配合自旋的失败重试办法。  
&emsp;3.2、把内存的动态分配按照线程划分在不同的空间之中进行，每个线程预先分配缓冲（TLAB）,线程的缓冲用完之后，分配新的缓冲时再采用同步锁定的方式保证安全。  
4、将分配到的内存空间初始化零值（除对象头之外）。保证对象的实例字段在不给初值的情况下能直接使用。  
5、初始化对象头信息。对象的GC分代年龄，属于哪一个类的实例，怎么寻找对象的元数据信息等。  
做完这些，一个虚拟机层面可用的对象才算创建成功，但是从Java程序的角度，才刚刚开始创建对象，执行构造方法<init>,将对象需要的资源按照它预定的意图创建好。  

### Java对象的内存布局
一个Java对象在堆内存中的结构由三部分组成：对象头,实例数据，对齐填充。  
对象头：有两部分组成，第一部分是对象自身的运行时数据：hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向线程的ID,偏向时间戳等。
另一部分是类型指针，对象指向它元数据的指针，通过这个指针来判断是能够类的实例。  
实例数据：对象真正存储的有效信息，longs/doubles,ints,oops等......相同宽度字段总是分配到一起存放。  
对齐填充：补充这个对象到8字节的整数倍。

### Java对象的访问定位方式
两种方式，句柄池和直接指针。  
句柄池：堆内存中开辟出来的一块空间作为句柄池，reference中存储的是句柄池的地址，句柄再指向对象实际的地址。（优点：reference存储的是一个稳定的地址，当对象的实际地址改变的时候，改变的是句柄的指针，reference不会改变）。  
直接指针：reference直接指向的就是对象实际的地址。（优点：节省了一次指针定位的时间）  
HotSpot使用的是直接指针。  

### OOM情况
OOM heap space  对象的总容量触及了最大堆的容量  
StackOverFlowError 栈深度大于允许的最大深度,如果设置栈运行动态扩容，当扩展栈内存的时候无法申请到内存的时候就会报OOM JavaVMStackSOF.leak
OOM PermGen space 运行时常量池溢出，方法区，使用Cglib代理的时候需要注意  
OOM directMemory 使用了直接内存，Netty,NIO等场景时需要注意  


## 二、垃圾收集器与内存分配策略
Java与C++之间永远隔着一堵由动态内存分配和垃圾收集技术围成的高墙，里面的人想出来，外面的人想进去。  
当需要排查各种内存溢出、内存泄露等问题的时候，当垃圾收集成为系统要达到更高并发的瓶颈的时候，就需要对这些自动化的技术实施的细节进行监控和调整。    
程序计数器、虚拟机栈、本都方法栈三个区域随着线程的死亡而死亡，栈中的栈帧随着方法的调用和返回而不断的进栈出栈。    
而Java的堆和方法区两个空间有着明显的不确定性。一个类的多个不同实现类，一个方法不同的条件分支也是无法确定的。只有当程序运行起来，才知道这些信息，而这些信息时时刻刻都在发生着变化。垃圾收集器关注的正是这一部分内存空间应该如何管理。  

### 判断对象已死
引用计数法：有引用就让计数器的值加一，没有就减一，当计数器的值为0，则代表对象不可能再被使用。无法解决循环引用的问题，已经被废弃的一种算法。  
可达新分析：通过一系列GC Root作为起始节点，通过引用关系向下搜索，如果一个对象到这些GC Roots之间都没有引用链路，判断对象不可达。可以被垃圾回收。  
可以作为GC Root的对象有：  
1、栈帧中的本地变量表中的引用对象（参数，局部变量，临时变量）  
2、方法区中类静态属性引用的对象（Java类的引用类型静态变量）  
3、在方法区中常量引用  
4、本地方法栈中的JNI(native方法)引用的对象  
5、Java虚拟机的内部引用（常驻异常对象，系统类加载器）
6、被synchronized关键字持有的对象
7、反映虚拟机情况的JMXBean,本地代码缓存等

### 引用分类
强软弱虚，在缓存系统中经常使用软引用和弱引用。  
**强引用**：强引用关系还在，永远不会被回收。    
**软引用**：在系统将要发生内存溢出异常的时候，会把软引用放入回收范围之内进行第二次回收，如果还是没有足够的空间才会抛出内存泄露的异常。  
**弱引用**：之内存活到下一次垃圾收集发生之前。  
**虚引用**：无法通过这种引用获得对象实例。唯一的作用就是在这个对象被垃圾收集的时候收到一个系统通知。  

### 对象的自我拯救
经过可达性分析之后，没有与GC Roots相连的对象会被标记，随后会对这些对象进行一次筛选，是否有必要执行finalize()方法。  
若对象没有覆盖finalized方法或者这个对象已经执行过了finalized方法，都会被认为是没有必要执行，接着就会被回收。  
被判定为有必要的对象，就会进入一个F-Queue队列中让他们去执行它们各自的finalized方法。  
这个时候假如有对象在finalized方法中再次调用自己，或者是执行缓慢，这样做的目的就是不想被回收。  
所以虚拟机一开始的设定是假如对象已经执行过一个finalized方法也被判定为没必要，直接被回收。   
对象唯一的自我拯救机会是在finalized方法中，将自己与GC Root上的对象建立引用链路即可，这样在第二次标记的时候就会被移除F-Queue队列。  
这种拯救方法只能被使用一次。第二次被判定不可达的时候，虚拟机不会让对象有机会执行finalized方法。  
并且这种拯救对象的方法是极力不推荐的。建议忘记Java中的finalized()方法。    

### 回收方法区
方法区回收的内容是废弃的常量和不再使用的类型。  
废弃常量：一个字符串"aaa"曾经出现在常量池中，但是当前系统没有任何一个字符串的值是"aaa",就需要把这个"aaa"常量移除常量池。类似的，方法，字段的符号引用也是这样的。  
类型不再使用：这个相对苛刻。要满足三个要求。1、这个类的实例都已经被回收。2、加载这个类的类加载器也被回收。3、这个类对应的反射对象也被回收，保证无法通过反射去访问这个类的方法。  
在大量使用反射，动态代理，Cglib等字节码框架的场景中，需要Java虚拟机具备类型卸载能力，保证不会对方法区造成太多的内存压力。  
  

### 分代收集理论
**弱分代假说**：绝大多数对象都是朝生夕死。   
**强分代假说**：熬过越多次垃圾收集的对象，就越难以消亡。  
  
这两个假说决定了很多垃圾收集器的设计理念和统一原则：应该将堆划分成不同的区域，将对象依据年龄分配到不同的区域中进行存储。  
这样，同一个区域中的对象年龄就大概是相同的，这样做的好处是：  
如果同一个区域的对象基本都是朝生夕死，集中放在一起，就只需要关注保留少量的存活，不去标记那些大量会被收集的对象。  
如果同一个区域的对象基本都是难以消亡的对象，集中在一起，只需要使用较低的评率来回收这个区域的对象即可。同时兼顾了内存开销和时间开销。  
  
但是这些概念还不足够解决复杂的垃圾收集的问题，因为会存在着跨代引用的问题。新生代对象被老年代引用，老年代也会被新生代引用。难道要去扫描整个老年代或者新生代？  
所以有了第三个**跨代引用假说**：跨带引用相对于同代引用来说仅仅占极少数。隐含的意思就是，互相引用的两个对象，应该是倾向于同时生存或者同时消亡。  
比如:某个新生代的对象引用了老年代对象，新生代的对象会在收集的时候得以存活，随着年龄的增长也来到老年代中。
利用这条假说，在新生代上建立一个全局的记忆集结构，这个结构把老年代划分成若干个小块，标识出哪一块内存会存在跨带引用。  
当发生了新生代的垃圾回收的时候，只需要把那些被标记了有跨带引用的老年代中对象作为GC Root即可。  
这种方法需要在对象改变了引用之后，维护记录数据的正确性，会增加一些额外的开销，但是比起全部扫描整个老年代来说，是很划算的。  
  
部分收集：不是对整个堆内存进行垃圾收集。分为：  
新生代收集：Minor GC / Young GC  
老年代收集：Major GC / Old GC  
混合收集： Mix GC 收集整个新生代和部分老年代，目前只有G1收集器有这种行为  
整堆收集：Full GC 

### 标记-清除算法
先标记需要收集的对象，回收所有被标记的对象。或者也可以标记存活对象，回收所有没有被标记的对象。   
这种算法有两个主要缺点：  
1、执行效率不稳定。有时堆中的大量对象需要被回收，对象的数量决定了执行的效率。
2、空间碎片化。会产生大量不连续的内存碎片。若后面有大对象被创建，就不得不再一次进行垃圾回收，间接导致GC频繁发生。


### 标记-复制算法
准确的说是半区复制，把实际容量划分为相等的两份，把存活下来的对象赋值到另外一个半区上，然后把已经使用过的内存空间清理掉。  
如果内存中的大部分对象在GC Root之后大部分是存活的，就会产生大量的复制开销。   
如果内存中只有少部分是存活的，就能很好的解决内存碎片问题。    
优缺点是很明显的，实现简单，运行高效。缺点就是实际可用空间只有一半。  
这种算法被运用在具有“朝生夕死”的新生代上，IBM公司的研究显示，98%的对象都熬不过第一轮的垃圾收集。所以根本不需要1:1的比例。  
  
1989年，出现了一种更加优化的半区优化策略——Appel式回收。HotSpot虚拟机的Serial、ParNew收集器都是采用这种思想。  
具体做法是：把新生代划分成一块比较大的区域Eden区（伊甸园区）和两块比较小的Survivor区（幸存者0区，幸存者1区），当幸存者区域不足以存放一次Miner GC之后幸存对象的时候，就需要依赖其他内存区域进行分配担保（**逃生门安全设计**）。
对象只分配在伊甸园区和其中的一个幸存者区，发生垃圾收集的时候，把存活的对象一次性复制到另一块幸存者区域，然后清理到伊甸园区和已经用过的那块幸存者区域的内存空间。  
HotSpot虚拟机的伊甸园区和两块幸存者区域的比例是 8:1:1  


  















