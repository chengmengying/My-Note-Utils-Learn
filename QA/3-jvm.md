# JVM
格式上才去 QA 这种格式式，每个问题后面换行两次。小标题慢慢梳理。
## 一、基本认知
Q:JVM是什么？    <br>
A:
<br><br>

Q:    <br>
A:    
<br><br>

  


## 二、

## 三、

## 四、

## 五、


## 《深入理解Java虚拟机》周志明
#### 展望未来  
即时编译器：应用系统预热之后，热点代码被HotSpot的探测机制定位捕获，将其编译为物理硬件可以直接指向的机器码。所以即时编译器输入代码的质量也决定了代码运行的效率。  
C1:耗时短，输出代码优化程度低的客户端编译器  
C2:耗时长，但是输出代码优化质量更高的服务端编译器 Graal编译器作为C2的替代产品。  
本地类型变量推断  

### 一、Java内存区域与内存溢出异常 
Java与C++之间隔着内存动态分配和垃圾收集器。  
  
#### 运行时数据区  
1、程序计数器：当前线程所执行的字节码的行号指示器。下一条指令的地址。字节码解释器改变这个计数器的值来选取下一条需要执行的字节码指令。
它是程序控制流的指示器，分支、循环、异常等等都需要依赖于这个计数器。  
Java的多线程是通过线程轮流切换、分配CPU执行时间来实现的。在一个确定的时间，cpu只可能执行其中的一条指令，为了切换线程之后能找到准确的位置，程序计数器是线程私有的。    
若某个线程正在执行的是一个Java方法，那么这个线程的程序计数器是字节码指令的地址。如果正在执行的是本地方法Native，这个计数器的值是空Undefined。
这个区域不会有OutOfMemoryError。
  
2、Java虚拟机栈：描述的是Java方法执行线程内存模型。每个方法被执行的时候都会创建一个栈帧 Stack Frame,里面存储的是局部变量表、操作数栈、动态链接、方法出口等信息。  
存储局部变量的空间是以Solt槽来表示，除了double和long类型是占据两个槽之外，其余的数据类型只占用一个。  
如果线程请求栈的深度大于虚拟机允许的深度，将抛出StackOverlowError异常，如果是运行虚拟机栈容量是可以扩容的，当请求不到足够的内存时，会抛出OutOfMemoryError异常。  
  
3、本地方法栈：与虚拟机栈发挥的作用相似。虚拟机栈为Java方法服务（字节码），本地方法栈为本地方法提供服务（Native）。

4、堆：虚拟机管理的内存中最大的一块，被所有线程共享，唯一目的就是存放对象实例。几乎所有的对象实例都会在这里被分配。  
几乎（即时编译技术的进步，逃逸分析，栈上分配，标量替换，这些技术使得在堆中分配对象是不绝对的）  
现代的大部分垃圾收集理论都是基于分代收集的概念设计的，所以有新生代，老年代，永久代，Eden区，幸存者from区，幸存者to区域。  
线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB）,用于提升对象分配的效率。
堆空间在物理上不连续，在逻辑上连续。虚拟机参数可以设定堆的大小。-Xmx和-Xms,当堆没有内存能完成实例分配，堆也无法再扩展的时候，就会抛出OutOfMemory异常。

5、方法区：每个线程的共享数据，用于存储已经被虚拟机加载的类型信息、常量、静态常量、即时编译器编译之后的代码缓存等数据。  
运行时常量池也是方法区的一部分。Class文件中除了有版本、字段、方法、接口，还有常量池Conttant Pool Table,存储编译期间生产的各种字面量与符号引用，当类加载了之后，，这些信息就被存放到方法区的运行时常量池中。另外，运行期间也能动态的把新的常量放入池中。
当无法申请到内存的时候会抛出OutOfMemory异常。  

6、直接内存：不是虚拟机运行时数据区的一部分，但是频繁使用，也会导致OOM。
NIO:一种基于通道和缓冲区的IO方式，它可以直接使用Native方法直接分配堆外内存，通过堆内存中的DierctByteBuffer直接操作内存数据，能显著提升IO性能。
当设置内存时，若忽略掉这部分数据，使得内存区域的综合超过了物理内存的限制，在动态扩展的时候就会出现OOM。

#### HotSpot虚拟机在新建对象的时候到底发生了什么？   
Java程序在运行过程中无时无刻都在创建对象，当虚拟机遇到一条创建对象的字节码指令的时候：  
1、首先检查指令的参数在常量池中是否能够定位到一个类的符号引用，并且检查这个符号引用的类是否已经被加载、解析、初始化过。（检查要创建的对象的类型是否在常量池中存在。）  
2、加载完毕之后开始为这个对象分配内存，所需要的内存空间大小在类加载之后是能够确定的。  
&emsp;2.1、指针碰撞：假设堆内存是规整的（使用过的内存和空闲的内存时隔开的，中间使用指针作为界线指示器），就只需要把指针往空闲方挪动即可，步长等于对象在加载之后的确定的需要占据空间的大小。  
&emsp;2.2、空闲列表：假设堆内存不是规则的，虚拟机就必须维护一个记录堆空间使用情况列表，从列表中找出一块足够大的空间划分给该对象。  
&emsp;因此，选择哪种分配方式由堆内存是否规整决定，而堆内存是否规整又由使用的垃圾收集器是否具有压缩整理能力决定。  
&emsp;比如：Serial,ParNew是具有压缩整理能力的垃圾收集器，可以使用指针碰撞办法来分配对象内存，而像CMS这种基于清除算法的收集器，理论上只能使用复杂的空闲列表分配算法来分配对象的内存。  
3、空间划分完毕之后，还有考虑线程的安全性问题。创建对象的动作在虚拟机中是非常频繁的。    
&emsp;3.1、采用CAS配合自旋的失败重试办法。  
&emsp;3.2、把内存的动态分配按照线程划分在不同的空间之中进行，每个线程预先分配缓冲（TLAB）,线程的缓冲用完之后，分配新的缓冲时再采用同步锁定的方式保证安全。  
4、将分配到的内存空间初始化零值（除对象头之外）。保证对象的实例字段在不给初值的情况下能直接使用。  
5、初始化对象头信息。对象的GC分代年龄，属于哪一个类的实例，怎么寻找对象的元数据信息等。  
做完这些，一个虚拟机层面可用的对象才算创建成功，但是从Java程序的角度，才刚刚开始创建对象，执行构造方法<init>,将对象需要的资源按照它预定的意图创建好。  

#### Java对象的内存布局
一个Java对象在堆内存中的结构由三部分组成：对象头,实例数据，对齐填充。  
对象头：有两部分组成，第一部分是对象自身的运行时数据：hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向线程的ID,偏向时间戳等。
另一部分是类型指针，对象指向它元数据的指针，通过这个指针来判断是能够类的实例。  
实例数据：对象真正存储的有效信息，longs/doubles,ints,oops等......相同宽度字段总是分配到一起存放。  
对齐填充：补充这个对象到8字节的整数倍。

#### Java对象的访问定位方式
两种方式，句柄池和直接指针。  
句柄池：堆内存中开辟出来的一块空间作为句柄池，reference中存储的是句柄池的地址，句柄再指向对象实际的地址。（优点：reference存储的是一个稳定的地址，当对象的实际地址改变的时候，改变的是句柄的指针，reference不会改变）。  
直接指针：reference直接指向的就是对象实际的地址。（优点：节省了一次指针定位的时间）  
HotSpot使用的是直接指针。  

#### OOM情况
OOM heap space  对象的总容量触及了最大堆的容量  
StackOverFlowError 栈深度大于允许的最大深度,如果设置栈运行动态扩容，当扩展栈内存的时候无法申请到内存的时候就会报OOM JavaVMStackSOF.leak
OOM PermGen space 运行时常量池溢出，方法区，使用Cglib代理的时候需要注意  
OOM directMemory 使用了直接内存，Netty,NIO等场景时需要注意  


### 二、垃圾收集器与内存分配策略
Java与C++之间永远隔着一堵由动态内存分配和垃圾收集技术围成的高墙，里面的人想出来，外面的人想进去。  
当需要排查各种内存溢出、内存泄露等问题的时候，当垃圾收集成为系统要达到更高并发的瓶颈的时候，就需要对这些自动化的技术实施的细节进行监控和调整。    
程序计数器、虚拟机栈、本都方法栈三个区域随着线程的死亡而死亡，栈中的栈帧随着方法的调用和返回而不断的进栈出栈。    
而Java的堆和方法区两个空间有着明显的不确定性。一个类的多个不同实现类，一个方法不同的条件分支也是无法确定的。只有当程序运行起来，才知道这些信息，而这些信息时时刻刻都在发生着变化。垃圾收集器关注的正是这一部分内存空间应该如何管理。  

#### 判断对象已死
引用计数法：有引用就让计数器的值加一，没有就减一，当计数器的值为0，则代表对象不可能再被使用。无法解决循环引用的问题，已经被废弃的一种算法。  
可达新分析：通过一系列GC Root作为起始节点，通过引用关系向下搜索，如果一个对象到这些GC Roots之间都没有引用链路，判断对象不可达。可以被垃圾回收。  
可以作为GC Root的对象有：  
1、栈帧中的本地变量表中的引用对象（参数，局部变量，临时变量）  
2、方法区中类静态属性引用的对象（Java类的引用类型静态变量）  
3、在方法区中常量引用  
4、本地方法栈中的JNI(native方法)引用的对象  
5、Java虚拟机的内部引用（常驻异常对象，系统类加载器）
6、被synchronized关键字持有的对象
7、反映虚拟机情况的JMXBean,本地代码缓存等

#### 引用分类
强软弱虚，在缓存系统中经常使用软引用和弱引用。  
**强引用**：强引用关系还在，永远不会被回收。    
**软引用**：在系统将要发生内存溢出异常的时候，会把软引用放入回收范围之内进行第二次回收，如果还是没有足够的空间才会抛出内存泄露的异常。  
**弱引用**：之内存活到下一次垃圾收集发生之前。  
**虚引用**：无法通过这种引用获得对象实例。唯一的作用就是在这个对象被垃圾收集的时候收到一个系统通知。  

#### 对象的自我拯救
经过可达性分析之后，没有与GC Roots相连的对象会被标记，随后会对这些对象进行一次筛选，是否有必要执行finalize()方法。  
若对象没有覆盖finalized方法或者这个对象已经执行过了finalized方法，都会被认为是没有必要执行，接着就会被回收。  
被判定为有必要的对象，就会进入一个F-Queue队列中让他们去执行它们各自的finalized方法。  
这个时候假如有对象在finalized方法中再次调用自己，或者是执行缓慢，这样做的目的就是不想被回收。  
所以虚拟机一开始的设定是假如对象已经执行过一个finalized方法也被判定为没必要，直接被回收。   
对象唯一的自我拯救机会是在finalized方法中，将自己与GC Root上的对象建立引用链路即可，这样在第二次标记的时候就会被移除F-Queue队列。  
这种拯救方法只能被使用一次。第二次被判定不可达的时候，虚拟机不会让对象有机会执行finalized方法。  
并且这种拯救对象的方法是极力不推荐的。  

  



























