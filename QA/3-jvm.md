# JVM
格式上才去 QA 这种格式式，每个问题后面换行两次。小标题慢慢梳理。
## 一、基本认知
Q:JVM是什么？    <br>
A:
<br><br>

Q:    <br>
A:    
<br><br>

  


## 二、

## 三、

## 四、

## 五、


## 《深入理解Java虚拟机》周志明
**展望未来**   
即时编译器：应用系统预热之后，热点代码被HotSpot的探测机制定位捕获，将其编译为物理硬件可以直接指向的机器码。所以即时编译器输入代码的质量也决定了代码运行的效率。  
C1:耗时短，输出代码优化程度低的客户端编译器  
C2:耗时长，但是输出代码优化质量更高的服务端编译器 Graal编译器作为C2的替代产品。  
本地类型变量推断  

**Java内存区域与内存溢出异常**   
Java与C++之间隔着内存动态分配和垃圾收集器。  
  
运行时数据区  
1、程序计数器：当前线程所执行的字节码的行号指示器。下一条指令的地址。字节码解释器改变这个计数器的值来选取下一条需要执行的字节码指令。
它是程序控制流的指示器，分支、循环、异常等等都需要依赖于这个计数器。  
Java的多线程是通过线程轮流切换、分配CPU执行时间来实现的。在一个确定的时间，cpu只可能执行其中的一条指令，为了切换线程之后能找到准确的位置，程序计数器是线程私有的。    
若某个线程正在执行的是一个Java方法，那么这个线程的程序计数器是字节码指令的地址。如果正在执行的是本地方法Native，这个计数器的值是空Undefined。
这个区域不会有OutOfMemoryError。
  
2、Java虚拟机栈：描述的是Java方法执行线程内存模型。每个方法被执行的时候都会创建一个栈帧 Stack Frame,里面存储的是局部变量表、操作数栈、动态链接、方法出口等信息。  
存储局部变量的空间是以Solt槽来表示，除了double和long类型是占据两个槽之外，其余的数据类型只占用一个。  
如果线程请求栈的深度大于虚拟机允许的深度，将抛出StackOverlowError异常，如果是运行虚拟机栈容量是可以扩容的，当请求不到足够的内存时，会抛出OutOfMemoryError异常。  
  
3、本地方法栈：与虚拟机栈发挥的作用相似。虚拟机栈为Java方法服务（字节码），本地方法栈为本地方法提供服务（Native）。

4、堆：虚拟机管理的内存中最大的一块，被所有线程共享，唯一目的就是存放对象实例。几乎所有的对象实例都会在这里被分配。  
几乎（即时编译技术的进步，逃逸分析，栈上分配，标量替换，这些技术使得在堆中分配对象是不绝对的）  
现代的大部分垃圾收集理论都是基于分代收集的概念设计的，所以有新生代，老年代，永久代，Eden区，幸存者from区，幸存者to区域。  
线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB）,用于提升对象分配的效率。
堆空间在物理上不连续，在逻辑上连续。虚拟机参数可以设定堆的大小。-Xmx和-Xms,当堆没有内存能完成实例分配，堆也无法再扩展的时候，就会抛出OutOfMemory异常。

5、方法区













