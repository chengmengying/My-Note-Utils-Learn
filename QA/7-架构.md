##雪花算法
分布式全局唯一ID,在分布式系统中，往往需要对大量数据和消息进行唯一标识。需要一个能够生成全局唯一ID的系统。  
ID生成规则部分的硬性要求：1、全局唯一 2、趋势递增 3、单调递增 4、信息安全 5、含时间戳
ID生成系统的可用性要求：1、高可用 2、低延迟 3、高QPS    
在雪花算法之前，单体式应用的id一般是UUID或者是自增。  
**UUID**   
UUID(36位 32位+4位短线):性能比较好，本地生成，没有网络消耗。如果只是保证唯一性，已经足够了。  
但是存在的问题是，UUID是无序的,32位置的也很长，mysql官方推荐主键越短越好，因为索引会占据了很大的一部分空间。作为主键不太好。
最后，UUID索引，会导致B+树索引的分裂。每一次新的数据插入进来之后，为了做查询的优化，都会对索引的b+树进行修改，因为UUID是无序的，所以会导致对这个B+树进行大量的修改。
这样一些中间节点就会产生分裂，也会白白创建出许多不饱和的节点，降低了数据库插入数据的性能。  
  
**数据库自增主键**    
单体应用下是完全可以的，但是在集群情况下，坚决不可以使用自增。
分布式环境下，是使用mysql的自增id和replace into实现的。如果表中主键的值冲突了，就替代原来的记录。
这种方式获取自增主键的值，也不太合适。    
  
**基于Redis生成全局ID**  
Redis默认是单线程的，天生就是原子性，可以使用原子操作INCR和INCRBY来实现。
但是在Redis集群的情况下，同样MySQL一样需要设置不同的增长步长，同时key还要设置有效期。
假设一个集群中有5台机器，初始化key的值是12345，步长都是5，那么ID的情况就是：
A:1,6,11,16......
B:2,7,12,17......
C:3,8,13,18......
D:4,9,14,19......
E:5,10,15,20......
  
**雪花算法**  
推特的自增ID算法。








